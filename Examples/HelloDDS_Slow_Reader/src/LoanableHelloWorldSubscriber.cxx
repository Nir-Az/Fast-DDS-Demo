// Copyright 2021 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file LoanableHelloWorldSubscriber.cpp
 * This file contains the implementation of the subscriber functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/subscriber/DataReader.hpp>
#include <fastdds/dds/subscriber/SampleInfo.hpp>
#include <fastdds/dds/subscriber/Subscriber.hpp>
#include <fastdds/dds/subscriber/qos/DataReaderQos.hpp>

#include "LoanableHelloWorldSubscriber.h"
#include "LoanableHelloWorldPubSubTypes.h"

using namespace eprosima::fastdds::dds;

LoanableHelloWorldSubscriber::LoanableHelloWorldSubscriber()
    : participant_( nullptr )
    , subscriber_( nullptr )
    , topic_( nullptr )
    , reader_( nullptr )
    , type_( new LoanableHelloWorldPubSubType() )
{
}

LoanableHelloWorldSubscriber::~LoanableHelloWorldSubscriber()
{

    // Signal the GuardCondition to force the WaitSet to wake up
    terminate_condition_.set_trigger_value( true );

    // Wait for the thread to finish
    if( _thread.joinable() )
        _thread.join();

    if( reader_ != nullptr )
    {
        subscriber_->delete_datareader( reader_ );
    }
    if( topic_ != nullptr )
    {
        participant_->delete_topic( topic_ );
    }
    if( subscriber_ != nullptr )
    {
        participant_->delete_subscriber( subscriber_ );
    }
    DomainParticipantFactory::get_instance()->delete_participant( participant_ );
}

bool LoanableHelloWorldSubscriber::init( bool use_copy, bool slow )
{
    _slow = slow;
    _use_copy = use_copy;

    // CREATE THE PARTICIPANT
    DomainParticipantQos pqos;
    pqos.name( "Participant_sub" );

    // Indicates for how much time should a remote DomainParticipant consider the local
    // DomainParticipant to be alive. If the liveliness of the local DomainParticipant has not being
    // asserted within this time, the remote DomainParticipant considers the local DomainParticipant
    // dead and destroys all the information regarding the local DomainParticipant and all its
    // endpoints.
    pqos.wire_protocol().builtin.discovery_config.leaseDuration = { 10, 0 };  //[sec, nsec]

    participant_ = DomainParticipantFactory::get_instance()->create_participant( 0, pqos );
    if( participant_ == nullptr )
    {
        return false;
    }

    // REGISTER THE TYPE
    type_.register_type( participant_ );

    // CREATE THE SUBSCRIBER
    subscriber_ = participant_->create_subscriber( SUBSCRIBER_QOS_DEFAULT, nullptr );
    if( subscriber_ == nullptr )
    {
        return false;
    }

    // CREATE THE TOPIC
    topic_ = participant_->create_topic( "RS_FRAME", type_.get_type_name(), TOPIC_QOS_DEFAULT );
    if( topic_ == nullptr )
    {
        return false;
    }

    // CREATE THE READER
    DataReaderQos rqos = subscriber_->get_default_datareader_qos();

    // The 'depth' parameter of the History defines how many samples are stored before starting to
    // overwrite them with newer ones.
    rqos.history().kind = KEEP_LAST_HISTORY_QOS;
    rqos.history().depth = 1;

    // TODO - Explain why
    rqos.reliability().kind = RELIABLE_RELIABILITY_QOS;
    //rqos.reliability().kind = BEST_EFFORT_RELIABILITY_QOS;

    // The Subscriber receives samples from the moment it comes online, not before
    rqos.durability().kind = VOLATILE_DURABILITY_QOS;

    // Activate the use of DataSharing. Entity creation will fail if requirements for DataSharing
    // are not met The input shared memory folder can be changed into a specific folder but must be
    // aligned with the readers
    rqos.data_sharing().on( "" );

    // Strict samples pre-alocated pool to minimum size needed
    rqos.resource_limits().max_samples = 1;
    rqos.resource_limits().allocated_samples = 1;
    rqos.resource_limits().extra_samples = 0;

    reader_ = subscriber_->create_datareader( topic_, rqos, &listener_ );
    if( reader_ == nullptr )
    {
        return false;
    }

    wait_set_.attach_condition( terminate_condition_ );
    wait_set_.attach_condition( reader_->get_statuscondition() );
    _thread = std::thread( &LoanableHelloWorldSubscriber::run, this );

    return true;
}

void LoanableHelloWorldSubscriber::SubListener::on_subscription_matched(
    DataReader *, const SubscriptionMatchedStatus & info )
{
    if( info.current_count_change == 1 )
    {
        matched = info.total_count;
        std::cout << "Subscriber matched." << std::endl;
    }
    else if( info.current_count_change == -1 )
    {
        matched = info.total_count;
        std::cout << "Subscriber unmatched." << std::endl;
    }
    else
    {
        std::cout << info.current_count_change
                  << " is not a valid value for SubscriptionMatchedStatus current count change"
                  << std::endl;
    }
}

void LoanableHelloWorldSubscriber::run()
{
    // Main loop is repeated until the terminate condition is triggered
    while( false == terminate_condition_.get_trigger_value() )
    {
        // Wait for any of the conditions to be triggered
        ReturnCode_t ret_code;
        ConditionSeq triggered_conditions;
        ret_code = wait_set_.wait( triggered_conditions, eprosima::fastrtps::c_TimeInfinite );
        if( ReturnCode_t::RETCODE_OK != ret_code )
        {
            std::cout << "Error on `wait()`, error code: " << std::to_string( ret_code() )
                      << std::endl;
            continue;
        }

        // Process triggered conditions
        for( Condition * cond : triggered_conditions )
        {
            StatusCondition * status_cond = dynamic_cast< StatusCondition * >( cond );
            if( nullptr != status_cond )
            {
                Entity * entity = status_cond->get_entity();
                StatusMask changed_statuses = entity->get_status_changes();

                // Process status. Liveliness changed and data available are depicted as an example
                if( changed_statuses.is_active( StatusMask::liveliness_changed() ) )
                {
                    std::cout << "Liveliness changed reported for entity "
                              << entity->get_instance_handle() << std::endl;
                }

                if( changed_statuses.is_active( StatusMask::data_available() ) )
                {
                    if ( _use_copy )
                        get_sample_safe( entity );
                    else
                        get_sample( entity );
                }
            }
        }
    }
}

void LoanableHelloWorldSubscriber::get_sample_safe( Entity * entity )
{
    LoanableHelloWorld data;

    SampleInfo info;
    DataReader * reader = static_cast< DataReader * >( entity );

    // Process all the samples until no one is returned
    while( ReturnCode_t::RETCODE_OK == reader->take_next_sample( &data, &info ) )
    {
        // Only samples for which valid_data is true should be accessed
        // valid_data indicates that the instance is still ALIVE and the `take` return an updated sample
        // is_sample_valid()` return always false - BUG on FastDDS, unlock when fixed
        if( info.valid_data /*&& reader->is_sample_valid(&data, &info)*/ )
        {
            const LoanableHelloWorld & sample = data;

            ++_samples;
            process_sample( sample );           
            if( ! info.valid_data )
                std::cout << "corrupted data found after processing! info validity is false" << std::endl;
        }
    }
}
void LoanableHelloWorldSubscriber::get_sample( eprosima::fastdds::dds::Entity * entity )
{
    FASTDDS_SEQUENCE( DataSeq, LoanableHelloWorld );
    DataSeq data;

    SampleInfoSeq infos;
    DataReader * reader = static_cast< DataReader * >( entity );

    // Process all the samples until no one is returned
    while( ReturnCode_t::RETCODE_OK == reader->take( data, infos ) )
    {
        // Both info_seq.length() and data_seq.length() will have the number of samples returned
        for( DataSeq::size_type i = 0; i < infos.length(); ++i )
        {
            // Only samples for which valid_data is true should be accessed
            // valid_data indicates that the instance is still ALIVE
            // is_sample_valid()` return always false - BUG on FastDDS, unlock when fixed
            if( infos[i].valid_data /* && reader->is_sample_valid(&data[0], &infos[0]) */)
            {
                const LoanableHelloWorld & sample = data[i];

                ++_samples;

                process_sample( sample );

                if( ! infos[i].valid_data )
                    std::cout << "corrupted data found after processing!" << std::endl;
            }
        }

        // must return the loaned sequences when done processing
        reader->return_loan( data, infos );
    }
}

void LoanableHelloWorldSubscriber::process_sample(const LoanableHelloWorld& sample)
{
                using namespace std::chrono;
                auto time_now_us
                    = duration_cast< microseconds >( system_clock::now().time_since_epoch() )
                          .count();
                std::cout << ( _slow ? "Slow " : "" ) << "Sample received (count=" << _samples
                          << ") at address " << &sample.data() << "  index=" << sample.index()
                          << " Time Since Published: " << ( time_now_us - sample.publish_time() )
                          << " [us]" << std::endl;
                
                // Verify first 1000 bytes are equal even after sleep in the middle
                // We sample the first byte, build a 100 char array out of it, sleep and than compare to the shared memory sample again
                // If the writer write on it the values will be different
                auto slot = sample.data()[0];
                std::vector<char> ref_buffer(1000, slot);
                
                // Simulate long processing time
                if( _slow )
                    std::this_thread::sleep_for( std::chrono::seconds( 1 ) );

                if (0 != memcmp(ref_buffer.data(), sample.data().data(), 1))
                    std::cout << "corrupted data found, first char is:" << slot << ", last is: " << sample.data()[999] << std::endl;

}
